name: 'Terraform Apply/Destroy - Dev Environment (CLI Backend Setup)' # 워크플로우 이름 변경

on:
  workflow_dispatch:
    inputs:
      action:
        description: '실행할 작업 선택 (apply 또는 destroy)'
        required: true
        default: 'apply'
      confirm_destroy:
        description: '삭제 작업을 확인하려면 DESTROY를 입력하세요'
        required: false
        default: ''

env:
  AWS_REGION: ca-central-1
  TF_BUCKET_NAME: jasonseo-dev-terraform-state       # 사용자 지정 버킷 이름
  TF_DYNAMODB_TABLE: jasonseo-dev-terraform-lock  # 사용자 지정 테이블 이름
  TF_STATE_KEY: terraform/dev/terraform.tfstate # 상태 파일 경로 (필요시 수정)

jobs:
  backend_setup:
    name: 'Ensure Terraform Backend Exists (Dev)' # Job 이름 변경
    runs-on: ubuntu-latest
    # 이 워크플로우에서는 output이 직접 필요하지 않음
    steps:
      # AWS CLI만 사용하므로 코드 체크아웃 불필요
      # - name: Checkout repository
      #   uses: actions/checkout@v2

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v1
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      # Terraform CLI 불필요
      # - name: Setup Terraform
      #   uses: hashicorp/setup-terraform@v1

      - name: Ensure Backend S3 Bucket and DynamoDB Table Exist
        run: |
          #!/bin/bash
          set -e # 오류 발생 시 즉시 중단

          BUCKET_NAME="${{ env.TF_BUCKET_NAME }}"
          DYNAMODB_TABLE="${{ env.TF_DYNAMODB_TABLE }}"
          REGION="${{ env.AWS_REGION }}"

          echo "Checking S3 bucket '$BUCKET_NAME' in region '$REGION'..."
          # head-bucket으로 존재 및 접근 권한 확인
          # AWS_ACCOUNT_ID secret이 없다면 --expected-bucket-owner 부분을 제거하세요.
          # if ! aws s3api head-bucket --bucket "$BUCKET_NAME" --expected-bucket-owner ${{ secrets.AWS_ACCOUNT_ID }} --region $REGION > /dev/null 2>&1; then
          if ! aws s3api head-bucket --bucket "$BUCKET_NAME" --region $REGION > /dev/null 2>&1; then
            echo "S3 bucket '$BUCKET_NAME' not found or inaccessible, attempting creation..."
            aws s3api create-bucket --bucket "$BUCKET_NAME" --region $REGION --create-bucket-configuration LocationConstraint=$REGION
            echo "Waiting for bucket '$BUCKET_NAME' to be ready..."
            aws s3api wait bucket-exists --bucket "$BUCKET_NAME" --region $REGION
            echo "Enabling bucket versioning..."
            aws s3api put-bucket-versioning --bucket "$BUCKET_NAME" --region $REGION --versioning-configuration Status=Enabled
            echo "Enabling server-side encryption (AES256)..."
            aws s3api put-bucket-encryption --bucket "$BUCKET_NAME" --region $REGION --server-side-encryption-configuration '{
              "Rules": [{"ApplyServerSideEncryptionByDefault": {"SSEAlgorithm": "AES256"}}]}'
            echo "Enabling block public access..."
             aws s3api put-public-access-block --bucket "$BUCKET_NAME" --region $REGION --public-access-block-configuration "BlockPublicAcls=true,IgnorePublicAcls=true,BlockPublicPolicy=true,RestrictPublicBuckets=true"
            echo "S3 Bucket '$BUCKET_NAME' created and configured."
          else
            echo "S3 bucket '$BUCKET_NAME' already exists."
          fi

          echo "Checking DynamoDB table '$DYNAMODB_TABLE' in region '$REGION'..."
          if ! aws dynamodb describe-table --table-name "$DYNAMODB_TABLE" --region $REGION > /dev/null 2>&1; then
            echo "DynamoDB table '$DYNAMODB_TABLE' not found, attempting creation..."
            aws dynamodb create-table \
              --table-name "$DYNAMODB_TABLE" \
              --attribute-definitions AttributeName=LockID,AttributeType=S \
              --key-schema AttributeName=LockID,KeyType=HASH \
              --billing-mode PAY_PER_REQUEST \
              --region $REGION
            echo "Waiting for DynamoDB table '$DYNAMODB_TABLE' to become active..."
            aws dynamodb wait table-exists --table-name "$DYNAMODB_TABLE" --region $REGION
            echo "DynamoDB table '$DYNAMODB_TABLE' created."
          else
            echo "DynamoDB table '$DYNAMODB_TABLE' already exists."
          fi
          echo "Backend resources check/setup complete."

  terraform_apply_destroy:
    name: 'Terraform Apply/Destroy (Dev)'
    runs-on: ubuntu-latest
    needs: backend_setup # backend_setup Job 완료 후 실행
    # environment: dev # 필요 시 환경 지정

    steps:
      - name: Checkout repository
        uses: actions/checkout@v2

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v1
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v1
        with:
          terraform_version: '1.8.0' # 버전 일관성 유지

      - name: Terraform Init (using S3 Backend) # <<<--- 중요: -backend-config 사용하도록 수정
        working-directory: environments/dev
        run: |
          # 일관성과 안정성을 위해 -backend-config 플래그 사용
          terraform init \
            -backend-config="bucket=${{ env.TF_BUCKET_NAME }}" \
            -backend-config="key=${{ env.TF_STATE_KEY }}" \
            -backend-config="region=${{ env.AWS_REGION }}" \
            -backend-config="dynamodb_table=${{ env.TF_DYNAMODB_TABLE }}" \
            -backend-config="encrypt=true"

      - name: Terraform Plan (Apply/Destroy용)
        working-directory: environments/dev
        run: terraform plan -out=tfplan -input=false

      - name: 파괴적 변경 사항 확인
        id: check_destructive
        working-directory: environments/dev # 작업 디렉토리 명시
        run: |
          # cd environments/dev # working-directory 설정으로 충분
          CHANGES=$(terraform show tfplan) || {
            echo "terraform show 실행 중 오류 발생:"
            # echo "$CHANGES" # 오류 시 큰 plan 출력될 수 있어 주석 처리
            exit 1
          }
          # echo "전체 terraform plan 출력:" # 디버깅 외에는 주석 처리 권장
          # echo "$CHANGES"
          if echo "$CHANGES" | grep -E '^\s*-|will be destroyed' > /dev/null; then # 파괴 감지 조건
            echo "파괴적 변경 사항 감지됨"
            echo "has_changes=true" >> $GITHUB_OUTPUT
          else
            echo "파괴적 변경 사항 없음"
            echo "has_changes=false" >> $GITHUB_OUTPUT
          fi

      - name: 파괴적 변경 사항 감지 시 실패 (Apply 모드에서만)
        if: steps.check_destructive.outputs.has_changes == 'true' && github.event.inputs.action == 'apply'
        run: |
          echo "ERROR: 파괴적 변경 사항이 감지되었습니다. Apply를 중단합니다."
          exit 1

      - name: Terraform Apply
        if: github.event.inputs.action == 'apply'
        working-directory: environments/dev
        run: terraform apply -auto-approve tfplan # 이전 단계에서 생성된 tfplan 사용

      - name: Terraform Destroy
        if: github.event.inputs.action == 'destroy' && github.event.inputs.confirm_destroy == 'DESTROY'
        working-directory: environments/dev
        run: |
          # Destroy는 자체적으로 계획을 생성하므로 tfplan 불필요
          terraform destroy -auto-approve






# name: 'Terraform Apply/Destroy - Dev Environment'

# on:
#   workflow_dispatch:
#     inputs:
#       action:
#         description: '실행할 작업 선택 (apply 또는 destroy)'
#         required: true
#         default: 'apply'
#       confirm_destroy:
#         description: '삭제 작업을 확인하려면 DESTROY를 입력하세요'
#         required: false
#         default: ''

# env:
#   AWS_REGION: ca-central-1

# jobs:
#   terraform_apply_destroy:
#     runs-on: ubuntu-latest
#     steps:
#       - name: 리포지토리 체크아웃
#         uses: actions/checkout@v2

#       - name: AWS 자격 증명 구성
#         uses: aws-actions/configure-aws-credentials@v1
#         with:
#           aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
#           aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
#           aws-region: ${{ env.AWS_REGION }}

#       - name: Terraform 설정
#         uses: hashicorp/setup-terraform@v1
#         with:
#           terraform_version: '1.8.0'

#       - name: Terraform 초기화
#         working-directory: environments/dev
#         run: | 
#           terraform init \
#               -backend-config="bucket=manoit-tfstate-bucket" \
#               -backend-config="key=dev/terraform/terraform.tfstate" \
#               -backend-config="region=${{ env.AWS_REGION }}" \
#               -backend-config="encrypt=true"

#       - name: Terraform 계획 (Apply/Destroy용)
#         working-directory: environments/dev
#         run: terraform plan -out=tfplan -input=false

#       - name: 파괴적 변경 사항 확인
#         id: check_destructive
#         run: |
#           cd environments/dev
#           CHANGES=$(terraform show tfplan) || {
#             echo "terraform show 실행 중 오류 발생:"
#             echo "$CHANGES"
#             exit 1
#           }
#           echo "전체 terraform plan 출력:"
#           echo "$CHANGES"

#           # 파괴(`-`) 작업을 감지
#           if echo "$CHANGES" | grep -E '^\s*-' > /dev/null; then
#             echo "파괴적 변경 사항 감지됨"
#             echo "has_changes=true" >> $GITHUB_OUTPUT
#           else
#             echo "파괴적 변경 사항 없음"
#             echo "has_changes=false" >> $GITHUB_OUTPUT
#           fi
  
#       - name: 파괴적 변경 사항 감지 시 실패 (Apply 모드에서만)
#         if: steps.check_destructive.outputs.has_changes == 'true' && github.event.inputs.action == 'apply'
#         run: |
#           echo "파괴적 변경 사항이 감지되었습니다..."
#           exit 1

#       - name: Terraform Apply
#         if: github.event.inputs.action == 'apply'
#         working-directory: environments/dev
#         run: | 
#           terraform apply -auto-approve tfplan

#       - name: Terraform Destroy 디버깅
#         if: github.event.inputs.action == 'destroy' && github.event.inputs.confirm_destroy == 'DESTROY'
#         working-directory: environments/dev
#         run: | 
#           # 디버깅을 위한 정보 출력
#           echo "GitHub 이벤트 입력 값: action=${{ github.event.inputs.action }}, confirm_destroy=${{ github.event.inputs.confirm_destroy }}"
          
#           # 상태 확인
#           echo "현재 Terraform 상태:"
#           terraform state list || echo "상태 파일에 리소스가 없거나 액세스할 수 없습니다."
          
#           # AWS 계정 정보 확인
#           echo "현재 AWS 자격 증명 정보:"
#           aws sts get-caller-identity || echo "AWS 자격 증명에 문제가 있습니다."
          
#           # 강제 리프레시
#           echo "상태 강제 리프레시 시도:"
#           terraform refresh
          
#           # 상세 디버그 로그로 디스트로이 실행
#           echo "디스트로이 실행 (상세 로그):"
#           TF_LOG=DEBUG terraform destroy -auto-approve





# name: 'Terraform Apply/Destroy - Dev Environment'

# on:
#   workflow_dispatch:
#     inputs:
#       action:
#         description: '실행할 작업 선택 (apply 또는 destroy)'
#         required: true
#         default: 'apply'
#       confirm_destroy:
#         description: '삭제 작업을 확인하려면 DESTROY를 입력하세요'
#         required: false
#         default: ''

# env:
#   AWS_REGION: ca-central-1

# jobs:
#   backend_setup:
#     name: 'Setup Terraform Backend (Dev)'
#     runs-on: ubuntu-latest
#     steps:
#       - name: 리포지토리 체크아웃
#         uses: actions/checkout@v2

#       - name: AWS 자격 증명 구성
#         uses: aws-actions/configure-aws-credentials@v1
#         with:
#           aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
#           aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
#           aws-region: ${{ env.AWS_REGION }}

#       - name: Terraform 설정
#         uses: hashicorp/setup-terraform@v1
#         with:
#           terraform_version: '1.8.0'

#       - name: 백엔드 리소스 확인 및 초기화
#         run: |
#           #!/bin/bash
#           check_bucket_exists() {
#               BUCKET_NAME="$1"
#               output=$(aws s3 ls "s3://$BUCKET_NAME" 2>&1)
#               if echo "$output" | grep -q 'NoSuchBucket'; then
#                   echo "false"
#               elif echo "$output" | grep -q 'Access Denied'; then
#                   echo "access denied"
#               else
#                   echo "true"
#               fi
#           }

#           check_dynamodb_exists() {
#               TABLE_NAME="$1"
#               output=$(aws dynamodb describe-table --table-name "$TABLE_NAME" 2>&1)
#               if echo "$output" | grep -q 'ResourceNotFoundException'; then
#                   echo "false"
#               elif echo "$output" | grep -q 'AccessDeniedException'; then
#                   echo "access denied"
#               else
#                   echo "true"
#               fi
#           }

#           # 백엔드 리소스 정의
#           S3_BUCKET="jasonseo-dev-terraform-state"
#           DYNAMODB_TABLE="jasonseo-dev-terraform-lock"

#           BUCKET_EXISTS=$(check_bucket_exists "$S3_BUCKET")
#           DYNAMODB_EXISTS=$(check_dynamodb_exists "$DYNAMODB_TABLE")

#           # 백엔드 Terraform 코드가 루트에 있으므로 별도 디렉토리 이동 없이 실행합니다.
#           if [ "$BUCKET_EXISTS" = "true" ] && [ "$DYNAMODB_EXISTS" = "true" ]; then
#               echo "S3 버킷과 DynamoDB 테이블 모두 존재합니다. Terraform init을 건너뜁니다."
#           elif [ "$BUCKET_EXISTS" = "access denied" ] || [ "$DYNAMODB_EXISTS" = "access denied" ]; then
#               echo "AWS 자격 증명에 문제가 있습니다. 종료합니다."
#               exit 1
#           else
#               echo "백엔드 리소스 중 일부가 존재하지 않으므로 Terraform 초기화를 수행합니다."
#               terraform init
#               terraform plan
#               terraform apply -auto-approve
#           fi

#   terraform_apply_destroy:
#     name: 'Terraform Apply/Destroy (Dev)'
#     runs-on: ubuntu-latest
#     needs: backend_setup
#     environment: dev
#     steps:
#       - name: 리포지토리 체크아웃
#         uses: actions/checkout@v2

#       - name: AWS 자격 증명 구성
#         uses: aws-actions/configure-aws-credentials@v1
#         with:
#           aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
#           aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
#           aws-region: ${{ env.AWS_REGION }}

#       - name: Terraform 설정
#         uses: hashicorp/setup-terraform@v1
#         with:
#           terraform_version: '1.8.0'

#       - name: Terraform 초기화
#         working-directory: environments/dev
#         run: terraform init

#       - name: Terraform 계획 (Apply/Destroy용)
#         working-directory: environments/dev
#         run: terraform plan -out=tfplan -input=false

#       - name: 파괴적 변경 사항 확인
#         id: check_destructive
#         run: |
#           cd environments/dev
#           CHANGES=$(terraform show tfplan) || {
#             echo "terraform show 실행 중 오류 발생:"
#             echo "$CHANGES"
#             exit 1
#           }
#           echo "전체 terraform plan 출력:"
#           echo "$CHANGES"
#           if echo "$CHANGES" | grep -E '^\s*-' > /dev/null; then
#             echo "파괴적 변경 사항 감지됨"
#             echo "has_changes=true" >> $GITHUB_OUTPUT
#           else
#             echo "파괴적 변경 사항 없음"
#             echo "has_changes=false" >> $GITHUB_OUTPUT
#           fi
      
#       - name: 파괴적 변경 사항 감지 시 실패 (Apply 모드에서만)
#         if: steps.check_destructive.outputs.has_changes == 'true' && github.event.inputs.action == 'apply'
#         run: |
#           echo "파괴적 변경 사항이 감지되었습니다..."
#           exit 1
      
#       - name: Terraform Apply
#         if: github.event.inputs.action == 'apply'
#         working-directory: environments/dev
#         run: terraform apply -auto-approve tfplan
      
#       - name: Terraform Destroy
#         if: github.event.inputs.action == 'destroy' && github.event.inputs.confirm_destroy == 'DESTROY'
#         working-directory: environments/dev
#         run: |
#           terraform destroy -auto-approve






